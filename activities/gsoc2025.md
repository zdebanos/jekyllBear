---
layout: page
title: GSoC 2025 Project
permalink: /activities/gsoc2025
---

Tl;dr for the GSoC evaluators - the proof of my work can be found here in these pull requests:

- [SHV Library](https://github.com/silicon-heaven/shv-libs4c/pull/11)
- [Integration of the SHV library into NuttX](https://github.com/apache/nuttx-apps/pull/3170)
- [Integration of the SHV library into pysimCoder, NXBoot updates](https://github.com/robertobucher/pysimCoder/pull/118)

As of 1st of September, I still need to address issues in the pull requests.

## Overview

The project I've participated in was called Firmware Upgrades over Silicon-Heaven Protocol for NXboot Demonstrated on pysimCoder.
Looking at the title, one may become lost in all the names used in the title.
Let's start slowly describing each part of my project!

### Silicon Heaven framework (SHV)

A framework with open-source protocol specification and implementation in many programming languages.
Developed and maintained by people from Elektroline, a.s., a Czech company.
The protocol specification can be found [here](https://silicon-heaven.github.io/shv-doc/index.html).

The protocol is used as a remote procedure call (RPC) system with custom serialization packing
schema (data serialization).
The fundamental structure in SHV is the communication tree comprised of nodes.
Each node has a set of methods, which are essentially just callbacks into my application.
In application, you can use the API to register your own functions as callbacks.

The SHV infrastructure requires a broker to handle all connected devices
(like in MQTT). This serves as a concentrator of all connected devices.

While Elektroline, a.s. has its own implementation in the C language,
my goal was to take the implementation already present in pysimCoder (more on that later),
developed by Michal Lenc, refine it, add file node implementation and
make a library out of it.
The advantage of my library lies in its simplicity - the whole communication
with the outer world just depends on two buffers - RX and TX, making
it feasible for memory constrained devices.

The only requirement to run this library is have an environment
where launching a communication thread is possible.

My new implementation is now located [here](https://github.com/silicon-heaven/shv-libs4c)
and supports POSIX out of the box, with tweaks to make it work
on Linux and NuttX.
Adaptation to any other RTOS (Zephyr, RTEMS, ThreadX) or Windows using Win32 API is possible.


### NuttX and NXBoot

Apache NuttX is a real-time operating system (RTOS) with an emphasis on standards compliance
and small footprint. Scalable from 8-bit to 64-bit microcontroller environments,
the primary governing standards in NuttX are POSIX and ANSI standards
(cited from [here](https://github.com/apache/nuttx)).

NXBoot is a bootloader developed by Michal Lenc as a replacement for MCUBoot.
NuttX features support for MCUBoot, however, Elektroline developers quickly
found out the scratchpad mechanism is a deadly killer for the external flash.
Since they couldn't get this fetaure into the MCUBoot's mainline,
they decided to implement this mechanism as a standalone bootloader into
NuttX.

NXBoot utilizes three image partitions: primary, secondary and tertiary.
The primary partition is usually the MCU's flash whereas secondary and
tertiary partitions, used as update and recovery partitions, are located
usually on an external flash.

NXBoot provides API for interacting with the update partition.
Each time new image is copied from the update partition into the primary
partition and started, the image must be then confirmed, otherwise
the primary partition is reflashed by the recovery image.

The goal of a firmware update tool is to interact with the update parititon,
check the checksum, reset the device and then confirm the image,
if the image booted up correctly.
More on the algorithm can be read [here](https://nuttx.apache.org/docs/latest/applications/boot/nxboot/index.html).

### pysimCoder

pysimCoder is a rapid control prototyping tool developed by professor
Roberto Bucher from SUPSI. In this project, we use it as a code generator
for control applications. We consider this as an open-source alternative
to Matlab/Simulink.

The tool supports code generation for NuttX, allowing to run control applications
directly on embedded devices running NuttX. To allow the tuning of the
quickly prototyped model, each block's parameters feature a getter and setter,
allowing to change model's parameters, such as signal references or PID controller's
parameters.

If turned on, the code generator can map each block to a SHV node, construct
a SHV tree and use these getters and setters as nodes' methods. This allows
for remote tuning of the model's parameters over TCP/IP, for example.

## The project goals

## The steps I've undergone
Here, I'll explain all the steps I've done to finish my GSoC 2025 project.

### shv-libs4c

### NuttX integration

### pysimCoder integration